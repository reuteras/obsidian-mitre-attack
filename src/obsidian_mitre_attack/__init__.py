"""Init file for project."""

from __future__ import annotations

import argparse
import datetime
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from typing import Any

import toml

from .markdown_generator import MarkdownGenerator
from .stix_parser import StixParser


def generate_domain_markdown(markdown_generator: MarkdownGenerator, domain: str) -> str:
    """Generate markdown files for a specific domain."""
    markdown_generator.create_tactic_notes(domain=domain)
    markdown_generator.create_technique_notes(domain=domain)
    markdown_generator.create_mitigation_notes(domain=domain)
    return f"Completed {domain}"


def create_main_readme(
    arguments: argparse.Namespace, domains: list[str], config: dict[str, Any]
) -> None:
    """Create the main README file for the MITRE ATT&CK collection."""
    attack_file = Path(arguments.output, "MITRE ATT&CK.md")
    with open(file=attack_file, mode="w", encoding="utf-8") as fd:
        content: str = "---\n"
        content += "alias:\n"
        content += "  - MITRE ATT&CK®\n"
        content += "tags:\n"
        content += f"  - {arguments.tags}mitre_attack\n"
        content += "---\n\n"

        content += "# MITRE ATT&CK®\n\n"
        content += "This is a collection of of the MITRE ATT&CK®[^mitre] framework for Obsidian.\n\n"
        current_date: str = datetime.datetime.now().strftime(format="%Y-%m-%d %H:%M:%S")
        content += (
            "Generated by obsidian-mitre-attack[^obsidian-mitre-attack] on "
            + current_date
            + ".\n\n"
        )
        content += "This collection is based on the following ATT&CK domains:\n\n"
        for domain in domains:
            content += (
                "- " + domain + " version " + str(object=config["version"]) + ".\n"
            )
        content += "\n[^obsidian-mitre-attack]: [https://github.com/reuteras/obsidian-mitre-attack](https://github.com/reuteras/obsidian-mitre-attack)\n"
        content += "[^mitre]: [MITRE ATT&CK®](https://attack.mitre.org/)\n"
        fd.write(content)


def main(argv: list[str] | None = None) -> None:
    """Main function for obsidian-mitre-attack.

    Args:
        argv: Command-line arguments. If None, uses sys.argv[1:].
    """
    domains: list[str] = ["enterprise-attack", "mobile-attack", "ics-attack"]
    parser = argparse.ArgumentParser(
        description="Download MITRE ATT&CK STIX data and parse it to Obsidian markdown notes."
    )

    parser.add_argument(
        "-o",
        "--output",
        dest="output",
        help="Output directory in which the notes will be saved.",
    )
    parser.add_argument(
        "-t",
        "--tags",
        dest="tags",
        help="Prepend this string to tags in the markdown files.",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        dest="verbose",
        action="store_true",
        help="Print verbose output.",
    )

    args: argparse.Namespace = parser.parse_args(argv)

    try:
        with open(file="config.toml", encoding="utf8") as fd:
            config: dict[str, Any] = toml.load(f=fd)
    except FileNotFoundError as error:
        raise FileNotFoundError("You need to create a 'config.toml' file.") from error

    if not args.output and not config["output_dir"]:
        raise ValueError("You need to provide an output directory")

    if not args.output:
        args.output = config["output_dir"]

    if not args.tags:
        args.tags = ""

    if not args.verbose:
        args.verbose = config["verbose"]

    start_time = time.time()
    print(f"Downloading MITRE ATT&CK STIX data version {config['version']}...")

    stix_data = StixParser(
        repo_url=config["repository_url"],
        version=config["version"],
        verbose=args.verbose,
    )
    print(f"✓ STIX Parser initialized ({time.time() - start_time:.2f}s)")

    output_dir: str = args.output
    Path(output_dir).mkdir(exist_ok=True, parents=True)

    parse_start = time.time()
    for domain in domains:
        domain_start = time.time()
        stix_data.get_domain_data(domain=domain)
        print(f"✓ Parsed {domain} ({time.time() - domain_start:.2f}s)")

    cti_start = time.time()
    stix_data.get_cti_data()
    print(f"✓ Parsed CTI data ({time.time() - cti_start:.2f}s)")
    print(f"✓ Total parsing time: {time.time() - parse_start:.2f}s")
    markdown_generator = MarkdownGenerator(
        output_dir=output_dir,
        stix_data=stix_data,
        arguments=args,
        config=config,
    )

    markdown_start = time.time()
    print("\nGenerating markdown files...")

    # Generate domain-specific markdown in parallel (tactics, techniques, mitigations)
    domain_gen_start = time.time()
    with ThreadPoolExecutor(max_workers=3) as executor:
        domain_futures = {
            executor.submit(
                generate_domain_markdown, markdown_generator, domain
            ): domain
            for domain in domains
        }
        for future in as_completed(domain_futures):
            domain = domain_futures[future]
            try:
                result = future.result()
                if args.verbose:
                    print(result)
            except Exception as e:
                print(f"Error generating markdown for {domain}: {e}")
                raise
    print(f"✓ Domain markdown generated ({time.time() - domain_gen_start:.2f}s)")

    # Generate CTI data markdown in parallel (software, groups, campaigns, assets, data sources, detection strategies, analytics)
    cti_gen_start = time.time()
    with ThreadPoolExecutor(max_workers=7) as executor:
        cti_futures = {
            executor.submit(markdown_generator.create_software_notes): "software",
            executor.submit(markdown_generator.create_group_notes): "groups",
            executor.submit(markdown_generator.create_campaign_notes): "campaigns",
            executor.submit(markdown_generator.create_asset_notes): "assets",
            executor.submit(
                markdown_generator.create_data_source_notes
            ): "data_sources",
            executor.submit(
                markdown_generator.create_detection_strategy_notes
            ): "detection_strategies",
            executor.submit(markdown_generator.create_analytic_notes): "analytics",
        }
        for future in as_completed(cti_futures):
            entity_type = cti_futures[future]
            try:
                future.result()
                if args.verbose:
                    print(f"Completed {entity_type}")
            except Exception as e:
                print(f"Error generating markdown for {entity_type}: {e}")
                raise
    print(f"✓ CTI markdown generated ({time.time() - cti_gen_start:.2f}s)")
    print(f"✓ Total markdown generation time: {time.time() - markdown_start:.2f}s")

    # Generate Main README file
    readme_start = time.time()
    create_main_readme(arguments=args, domains=domains, config=config)
    print(f"✓ README generated ({time.time() - readme_start:.2f}s)")

    print(f"\n{'=' * 60}")
    print(
        f"TOTAL TIME: {time.time() - start_time:.2f}s ({(time.time() - start_time) / 60:.2f} minutes)"
    )
    print(f"{'=' * 60}")
